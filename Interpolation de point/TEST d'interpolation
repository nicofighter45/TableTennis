class indicatrice() :
    def __init__(self, t1, t2,):
        self.intervale = (t1,t2)
    def __call__(self, point):
        if self.debut <= point and self.fin >= point :
            return(1)
        else : return(0)
    def __mul__(self,a):
        if isinstance(a,polynome) :
            return(ind_poly(self,a))
        else : raise TypeError("Opération de multiplication non prise en charge.")
    def __rmul__(self,a):
        return self.__mul__(a)
class matrice() :
    def __init__(self,listedeliste) :
        self.mat = listedeliste
        self.longueur = len(listedeliste[0])
        self.largeur = len(listedeliste)
    def __getitem__(self, indices):
        i, j = indices
        return self.donnees[i][j]
    def __setitem__(self, indices, valeur):
        i, j = indices
        self.donnees[i][j] = valeur
    def __repr__(self):
        return repr(self.donnees)
    def __add__(A,B):
        if A.longueur == B.longueur and A.largeur == B.largeur :
            return(matrice([[A[i][j] + B[i][j] for j in range (len(A[i]))] for i in range (len(A))]))
        else : return(False)
    def __mul__(A,B) :
        if isinstance(B,matrice) :
            n, m, l = A.largeur, A.longueur, B.longueur
            if m != B.largeur :
                raise Exception("The number of column of M1 must be the same as the number of line of M2")
            M = []
            for i in range(n):
                line = []
                for j in range(l):
                    sum = 0
                    for k in range(m):
                        sum += M1[i][k]*M2[k][j]
                    line.append(sum)
                M.append(line)
            return matrice(M)
        if isinstance(B,int) :
            for i in range (A.largeur) :
                for j in range (A.longueur) :
                    A[i][j]=A[i][j]*B
            return(A)
class polynome():
    def __init__(self, coefficient) :
        if not isinstance(coefficient,list) : raise TypeError("les coefficients doivent être sous la forme de liste")
        p=-1
        liste=[]
        while coefficient[p]==0 :
            p-=1
        if p!=-1 : self.coefficient = coefficient
        else : self.coefficient = coefficient[:p+1]
        self.degre = len(self.coefficient)-1
        if self.coefficient ==[] : self.coefdomi = 0
        else : self.coefdomi = coefficient[-1]
    def coef(self,deg):
        if deg > self.degre : return(0)
        return(self.coefficient[deg])
    def __call__(self, valeur) :
        somme=0
        for k in range(self.degre+1) :
            somme+=self.coefficient[k]*valeur**k
        return somme
    def __add__(b,a) :
        if isinstance(a,polynome) :
            liste =[]
            if a.degre <= b.degre :
                for k in range (len(a.coefficient)):
                    liste.append(a.coefficient[k]+b.coefficient[k])
            else :
                for k in range (len(b.coefficient)):
                    liste.append(a.coefficient[k]+b.coefficient[k])
            return(polynome(liste))
        elif isinstance(a,int) :
            b.coefficient[0]+=a
            return(b)
        else:
            raise TypeError("Opération d'addition non prise en charge.")
    def __radd__(self, a):
        return self.__add__(a)
    def __mul__(self, a):
        if isinstance(a, int):
            liste = [coef * a for coef in self.coefficient]
            return polynome(liste)
        elif isinstance(a, polynome):
            multi = polynome([])
            for i in range(a.degre + 1):
                liste = [coef * a.coef(i) for coef in self.coefficient]
                liste = [0] * i + liste
                multi += polynome(liste)
            return multi
        elif isinstance(a,indicatrice) :
            return(ind_poly(a,self))
        elif isinstance(a,ind_poly) :
            a.polynome = a.polynome * self
            return(a)
        else:
            raise TypeError("Opération de multiplication non prise en charge.")
    def __rmul__(self, a):
        return self.__mul__(a)
    def der(self) :
        return polynome([k*self.coefficient[k] for k in range (1,self.degre+1)])
class ind_poly():
    def __ind__(self,indicatrice,polynome) :
        self.indicatrice = indicatrice
        self.polynome = polynome
    def __call__(self, point) :
        if not self.indcatrice(point) : return 0
        else : self.polynome(point)
    def __add__(self,a):
        if isinstance(a,int) or isinstance(a,polynome) :
            self.polynome=self.polynome + a
            return self
        elif isinstance(a,ind_poly) :
            if self.indicatrice==a.indicatrice : 
                self.polynome = self.polynome + a.polynome
                return self
            else : 
                Somme =Sum_ind_poly([self,a])
                return(Somme)
        elif isinstance(a,Sum_ind_poly) :
            check = True
            for k in range (len(a.liste)) :
                if a.ind[k]==self.indicatrice : 
                    a.liste[k]= a.liste[k]+ self
                    check = False
            if check :
                a.liste.append(self)
                a.polynome.append(self.polynome)
                a.ind.append(self.indicatrice)
            return(a)
        else : raise TypeError("Opération d'addition non prise en charge.")
    def __radd__(self,a):
        return self.__add__(a)
    def ___mul__(self,a) :
            if isinstance(a,int) or isinstance(a,polynome) :
                self.polynome=self.polynome * a
                return self
            else : raise TypeError("Opération de multiplication non prise en charge.")
    def __rmull__(self,a):
        return self.__mul__(a)
class Sum_ind_poly():
    def __init__(self,List_ind_poly):
        self.liste = List_ind_poly
        self.polynome = [ l.polynome for l in List_ind_poly]
        self.ind = [ l.indicatrice for l in List_ind_poly]
    def __add__(self,a):
        if isinstance(a,int) or isinstance(a,polynome) :
            for k in self.polynome : k = k + a
            return self
        elif isinstance(a,ind_poly) : 
            check = True
            for k in range (len(self.liste)) :
                if self.ind[k]==a.indicatrice : 
                    self.liste[k]= self.liste[k]+ a
                    check = False
            if check :
                self.liste.append(a)
                self.polynome.append(a.polynome)
                self.ind.append(a.indicatrice)
            return(self)
        elif isinstance(a,Sum_ind_poly) :
            for k in a.liste :
                self = self + k
            return(self)
        else : raise TypeError("Opération d'addition non prise en charge.")
    def __radd__(self,a) :
        return self.__add__(a)
    def ___rmul__(self,a) :
        raise TypeError("Opération de multiplication non prise en charge.")